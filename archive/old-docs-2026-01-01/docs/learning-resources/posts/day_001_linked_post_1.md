# Day 001 — Technical deep dive: Turbopack, React Compiler, and dev experience

We opted to scaffold a modern Next.js app with the React Compiler enabled and experiment with Turbopack during development. The practical tradeoffs were clear: Turbopack offers dramatically faster incremental builds and dev server startup compared with traditional Webpack, which translates directly into developer velocity on iterative UI work. In our session the Next generator recommended Turbopack and auto-wired a `babel-plugin-react-compiler` dependency and a `reactCompiler: true` flag in `next.config.ts`. That combination reduces the cost of small edits (hot reloading latency), which is crucial when iterating on components and Tailwind-based styles.

However, the newer toolchain surface requires attention to native binaries and lockfile consistency — Next patched the lockfile to include `@next/swc` entries and we needed to run `npm install` to pull the SWC binaries. This is a small operational step but important: missing SWC binaries can produce warnings or slower builds. Another practical point was to isolate the app from existing projects — attempting to run `npx create-next-app meljonesai` failed because the directory existed; creating the project in a new folder avoided that problem.

In short, choosing Turbopack + React Compiler is a developer-experience-first decision: it shortens feedback loops and encourages rapid UI iteration. The tradeoffs are maturity and occasional native-binary housekeeping (lockfile updates and installs). For a product-led frontend where iteration speed and Core Web Vitals matter, the ergonomics win is worth the small operational overhead.
